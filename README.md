# Тестовое задание от одной из компаний
Задание выглядит так:

Используемые технологии:
- Go 
- JWT 
- PostgreSQL

**Задание:**

Написать часть сервиса аутентификации.

Два REST маршрута:
- Первый маршрут выдает пару Access, Refresh токенов для пользователя с идентификатором (GUID) указанным в параметре запроса
- Второй маршрут выполняет Refresh операцию на пару Access, Refresh токенов

**Требования:**

Access токен тип JWT, алгоритм SHA512, хранить в базе строго запрещено.

Refresh токен тип произвольный, формат передачи base64, хранится в базе исключительно в виде bcrypt хеша, должен быть защищен от изменения на стороне клиента и попыток повторного использования.

Access, Refresh токены обоюдно связаны, Refresh операцию для Access токена можно выполнить только тем Refresh токеном который был выдан вместе с ним.

Payload токенов должен содержать сведения об ip адресе клиента, которому он был выдан. В случае, если ip адрес изменился, при рефреш операции нужно послать email warning на почту юзера (для упрощения можно использовать моковые данные).

**Результат:**

Результат выполнения задания нужно предоставить в виде исходного кода на Github. Будет плюсом, если получится использовать Docker и покрыть код тестами.

# Как запустить? 
По умолчанию, запускаестя из Docker (чтобы БД сделать). Клонируйте репозиторий --> выполните команду `docker-compose up --build -d`. 

**Важно!** если после сборки контейнер с сервером не подключиться к БД, то просто перезапустите его. У меня несколько раз такое было и это случается если, именно, пересобирать с нуля. Первый раз такое, как решить, пока не знаю. А если выполнять сборку с уже работающими контейнерами, то все нормально.

<u> AcessToken - живет 2 минуты, а RefreshToken - живет 6 минут</u> 

Для запуска без Docker -->  нужно в <u>файле database.go</u> изменить настройки подключения к БД с env-файла на фактические значения, но база данных при этом, все равно должна быть поднята в Docker / где-то еще. Или можете настроить подключение к БД вручную, все в том же файле. И поставить порт сервера вручную в <u>файле routes.go</u>.


После запуска, для просмотра документации, перейдите по http://localhost:4000/swagger/index.html

# Что я не знал из этого?
Никогда не делал хранение Refresh токен в БД.

Как делать Refresh операцию, было только примерное представление.

Как отправлять email через Go.

# Как думал делать? 
Делать решил через фреймворк GIN. Было понимание, что такое токены, зачем нужны и ранее, уже делал их. Задание прислали на русском языке, поэтому комментарии и логи в коде на русском языке. 

Так получилось, что эти 2 REST маршрута - я написал за 2.5 вечера. И так как у меня было время и желание разобраться в других аспектах... 

Но я понмаю, делать то, что тебя не просят - **это не лучшая идея!**

Написано 7 REST маршрутов + сваггер на все это.
Я изначально понимал, примерно, где и как это предполагается использовать. 

Есть сервис - в нем регистрируется пользователь - далее, он входит под своими данными - ему выдаются AcessToken и RefreshToken. Токены нужны для доступа к защищенным маршрутам. 

RefreshToken нужен для обновления AcessToken, чтобы пользователя не выкидовало слишком часто. Именно это и есть __Refresh операция__ о которой написано в задании (я так понял задание). AcessToken, по времени живет меньше, чем RefreshToken.

Тут в PostgreSQL - 2 таблицы. Первая для пользователей, а вторая для сессий (где и будет храниться RefreshToken).

Чтобы реализовать доступ к защищенным маршрутам - нужен Middleware, который будет проверять, выполнен ли был вход.

Именно Middleware - мне был интересен, так как ранее, я его не писал, но понимал, что это и зачем нужен. И тут, попалась ситуация, где он уместен. Хороший повод разобраться. 

Middleware может делать что угодно, не только проверять аутентификацию. Это промежуточный обработчик в который заложена конкретная логика. В первую очередь, было интересно как передавать данные между маршрутами. 
<hr>
<hr>

# Выполнение
__Первый маршрут выдает пару Access, Refresh токенов для пользователя с идентификатором (GUID) указанным в параметре запроса__
- сначал подумал, что GUID == ID, но это не так. ID это число, а GUID 128-битное число:  `7bae70eb-8c24-4912-89cc-0bd994650f59`
- создание токенов:
	- AcessToken это JWT токен, в нагрузке которого есть ID сессии (где храниться RefreshToken), так нужно, чтобы связать токены вместе и нельзя было обновить AcessToken через другой RefreshToken, который не был создан вместе с ним. Сам токен, после создания, отправляется пользователю. 
	- RefreshToken это __не__ JWT токен, как я подумал изначально. Это тут просто запись в БД, в которой хранится хеш данного токена. А сам токен, __не хеш__ (строка base64) отправляется пользователю. Я вот так понял задание.


__RefreshToken - должен быть защищен от изменения на стороне клиента и попыток повторного использования__
- в БД храниться хеш через который мы проверяем (строку base64), если с хешем совпадения не будет, значит строку меняли
- в БД с сессиями есть поле GUID, оно должно быть уникальное, дубликат не получиться сделать. Если у RefreshToken закончится время и с таким попытаются зайти, то запись с ним удалится. При Refresh операции, старая запись удаляется.   

**Payload токенов должен содержать сведения об ip адресе клиента, которому он был выдан. В случае, если ip адрес изменился, при рефреш операции нужно послать email warning на почту юзера**
- добавить в нагрузку токенов данные я понимал как, я не знал как email отправить
- "email warning на почту", это когда google или VK присылают письма - вход с нового ip, если это не вы и т.д. Как я понял, тут хотят, примерно, это же. На youtube нашел видео, где без сторонних библиотек отправляли письмо. <u>Я отправил письмо с своей почты gmail на свою почту icloud</u>. Потом, данные для отправки письма (свою почту и пароль) удалил из кода. Маловероятно, что данная фича важна в этом задании. Но вы можете вставить туда свои данные и нет, пароль тут - это не пароль вашей учетной записи google. Это пароль приложения, который можно сгенирировать на специальной странице google. Если ничего не менять в коде, то при обновлении токенов, в логах будет сообщение об ошибке, что письмо не удалось отправить и ссылка от google на инструкцию.

**Будет плюсом, если получится использовать Docker и покрыть код тестами**

- Docker тут есть. Используется docker-compose, у нас 2 сервиса. База данных и сервер. У самого сервера многоступенчатая сборка, после которой остается только бинарник. Это нужно для уменьшения размеров образа.
- насчет тестов, я сделал сваггер, можете гонять JSONы. Не совсем понял, что тут хотели под "покрыть код тестами". Уменя там одна 1 функция есть, для которой напсиан тест и то он не мной написан (у меня VSCode - `>Go Generate Unit Tests For Function`) и тест сделают за тебя, я же только, наполнил его кейсами для тестирования. Я до этого, писал unit-тесты, а тут сервер надо тестировать что-ли, как покрывать именно сервер тестами я не знаю. Я не знаю как покрывать тестами обработчки, они же с БД взаимодействуют, получается - нужна отдельная БД для тестирования... 
<hr>
<hr>

# Выполнение того, что я добавил себе сам в задание
**Методы GET, POST, PUT, DELETE - сделаны для БД с пользователями**
- GET - получение данных, в самом получении данных ничего сложного. Сложности начались когда нужно было проверить - былали ли Refresh операция и если да, то вернуть новые токены в ответе. И вообще, вернуть в ответе как отработал Middleware. 
   - Вызвать Refresh операции из Middleware. Я сделал это через составления нового запроса. В Middleware формируется запрос, отправляется по нужному url и возвращаются либо токены, либо ошибка. Далее, мы все это отправлем пользователю. По сути, мало чем отличается от мы сами делаем запрос, код делает запрос. 
   - Как перегнать данные из одного обработчика в другой? передавать их в контексте. Куда, как выяснилось, можно записывать данные по ключу `ctx.Set()` и вытаскивать их далее `ctx.Get()`. Отправка же это `ctx.Next()`. Но к этому я пришел не сразу. Изначально, я в Middleware отправлял ответ от сервера в JSON и после вызывал `ctx.Next()`, а это не правильно. Но зато я понял как можно делать Middleware, это и была моя цель.
   - самого Middleware в сваггере нет, это же не путь на который специально делают запрос. Или, как его нужно отражать в документации к API я не знаю (разбираться не стал). 
- POST - ничего сложного.
- PUT - вот это самая плохая часть проекта. Сделан на 50%. Обновление данных защищенно Middleware, но если при обновлении, в Middleware будет вызвана Refresh операция, то тело запроса (где новые данные) не дойдет до самого PUT обработчика. А вот если при этом запросе AcessToken валидный, то Refresh операции не будет и новые данные дойдут. Получается, тут дело в запросе, который вызывается в Middleware при Refresh операции. Это точно можно как-то решить, но я не стал. И тут не выдаются новые токены, даже если они и были созданы в Middleware...
- DELETE - удаление пользователя и его сессии.

**Генерация сваггера к API**

Я недавно научился это делать, научился при выполнении другого тестового задания и вот тут применил. Но тут, кое-что сделал в певрый раз.

- как сделать защищенные методы в документации.
- как сделать, чтобы по конопке "Authorize" можно было ввести токены, чтобы не передавать их как параметры в каждом запросе, каждый раз.
- в каждом ответе сервера используется структура для ответа, я с самого начала понимал, что так смогу встроить в документацию модели (в прошлый раз я этого не сделал, использовал `gin.H{}`)
<hr>
<hr>

# Что тут можно улучшить? 
Метод PUT в первую очередь. 

Также, есть дублирование кода в некторых местах. Если бы знал зарнее, как весь проект будет выглядеть - вынес бы эти части в отдельные пакеты.


# ИИ? У нас так не принято. 
На самом деле, в задании еще было написано:


P.S. Друзья! Задания, выполненные полностью или частично с использованием chatGPT видно сразу. Если вы не готовы самостоятельно решать это тестовое задание, то пожалуйста, давайте будем ценить время друг друга и даже не будем пытаться :)

0% осуждения 100% понимания

<div style="text-align: center; font-size: 25px;">
Кода от ИИ тут нет!
</div><br>

chatGPT не использовался. Но другой ИИ помогал.


Как именно помогал? 
- Использовал его вместо чтения документации. Если есть вопрос, то ответ - вероятно есть в документации, но искать самому... Хотя, это не всегда срабатывало, стоит заметить, все же приходилось, обращаться к документации самому.
- ИИ напсиал регулярное выражения для тестирования функции, самому лень было.
- автокомплит у меня выключен.